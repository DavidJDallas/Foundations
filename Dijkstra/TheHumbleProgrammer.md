<h1> The Humble Programmer </h1>

<h2> Overview </h2>
This is a Turing lecture that Dijsktra gave in 1972. In it, he gives some brief biographical information about his start as a programmer/software engineer. 

Before presenting any arguments around the challenges that programming/software engineering faces, he mentions two opinions about programming from before-days:

(1) That a very competent programmer should be puzzle-minded and be fond of clever tricks. 

(2) 'Programming was nothing more than optimizing the efficiency of the computational process'.

The second opinion was the result of viewing the equipment as bad - the idea was that once the equipment improved, the problems of programming would be gone. This, of course, neglects the human element (my statement, for now, not Dijkstra's). He points out that the opposite of this result came about. More powerful machines came about, and we had a software crisis.

He diagnoses this crisis as having a minor and a major cause.

Minor: Modern machinery is more difficult to handle than older machinery.

Major: As power of machines grew, so did human's desire to do more complex things with them. The complexity of the programmes sprawled out, and we as humans struggled to write programmes that reduced this complexity. 

Then, we had even more complex computers in mid 1960s. 

Major developments in software:

(1) EDSAC in Cambridge, England, introduces the notion of the closed subroutine. This is essentially equivalent to functions/methods that we have now. It's so important because it 'caters for the implementation of one of our basic patterns of abstraction'. 

(2) Birth of FORTAN. Sees it as instantiaing bad habits into programmers. 

(3) Birth of LISP

(4) ALGOL 60. The report on this seen as a successful effort to carry abstraction a step further and defining a programming language in an implementation-independent way. 

(5) Pl/1 programming language. Frightening size and complexity.

He discusses a vision: that in the next 10 years, (before 1980), we shall be able to design and implement far greater and better systems, which will be of higher quality (bug-free). Dijkstra is sceptical of this but thinks that three major conditions must be fulfilled for this to take place:

First: World at large must recognise the need for change. He sees this as met, since 'it is now generally recognised that the design of any large sophisticated system is going to be a very difficult job'. 

Second: The economic need for it must be sufficiently strong. He thinks this has been satisfied.

Third: The change must be technically feasible. 

Since he gives quick arguments in conclusion to the first two parts, the remaining part of the essay is spent on the Third part. For this, he gives six arguments as to why this is technically feasible.

(1) As the programmer only needs to consider intellectually manageable programmes, the alternatives he is choosing between are much easier to cope with.

(2) As soon as we have decided to restrict ourselves to the subset of intellectually manageable programmes, we have achieved, once and for all, a drastic reduction of the solution space to be considered.

(3) 

(4)

(5) To do with the influence of the tool we are trying to use upon our own thinking habits. 
